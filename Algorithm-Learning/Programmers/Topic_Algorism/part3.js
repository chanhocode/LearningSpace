/*
직사각형을 만드는 데 필요한 4개의 점 중 3개의 좌표가 주어질 때, 나머지 한 점의 좌표를 구하려고 합니다.
점 3개의 좌표가 들어있는 배열 v가 매개변수로 주어질 때, 직사각형을 만드는 데 필요한 나머지 한 점의 좌표를
return 하도록 solution 함수를 완성해주세요. 단, 직사각형의 각 변은 x축, y축에 평행하며, 반드시 직사각형을 
만들 수 있는 경우만 입력으로 주어집니다.
  제한사항
- v는 세 점의 좌표가 들어있는 2차원 배열입니다.
- v의 각 원소는 점의 좌표를 나타내며, 좌표는 [x축 좌표, y축 좌표] 순으로 주어집니다.
- 좌표값은 1 이상 10억 이하의 자연수입니다.
- 직사각형을 만드는 데 필요한 나머지 한 점의 좌표를 [x축 좌표, y축 좌표] 순으로 담아 return 해주세요.
*/

// 나의 코드
function solution(v) {
  var answer = [
      []
  ];
  const xResult = v[0][0] === v[1][0] ? v[2][0] : v[0][0] === v[2][0] ? v[1][0] : v[0][0]
  const yResult = v[0][1] === v[1][1] ? v[2][1] : v[0][1] === v[2][1] ? v[1][1] : v[0][1]
  answer = [xResult,yResult]
  return answer;
}
console.log(solution([[1, 4], [3, 4], [3, 10]]))

// 해설 :: 자바코드
/*
- 조건문, 해시등을 이용해 구현 가능, 간단하게는 xor을 이용해서도 가능.
  A xor A = 0 -> A xor A xor B = B를 이용하면 다른 값 1개를 쉽게 구할 수 있다.

  #include <iostream>
#include <vector>
using namespace std;

vector<int> solution(vector<vector<int> > v) {
    vector<int> ans = {0,0};
    for(int i=0; i<3; i++)
    {
        ans[0] ^= v[i][0];
        ans[1] ^= v[i][1];
    }
    return ans;
}
*/

// 인상 깊은 코드

// xor 이용
function solution(v) {
  var answer = [
      []
  ];

  for(var i = 0; i < 3; i++) {
      answer[0] ^= v[i][0];
      answer[1] ^= v[i][1];
  }

  return answer;
}

/*
    JavaScript 비트 연산자
  
  1. 비트의 논리곱 (AND) " & "
    0 & 0 = 0, 0 & 1 = 0, 1 & 0 = 0, 1 & 1 = 1
  2. 비트의 논리합 (OR) " | "
    0 | 0 = 0, 0 | 1 = 1, 1 | 0 = 1, 1 | 1 = 1
  3. 베타적 논리합 " ^ "
    a 와 b 의 이진수를 한 자리씩 비트 ^ 연산을 합니다. ^는 같은 0,0 또는 1,1 일 경우에는
    0을 반환하고, 다를 경우 0,1 또는 1,0 과 같을 경우에는 1을 반환 합니다.
  4. 비트의 부정 연산을 하는 연산자 " ~ "
    값을 이진수 비트로 변환한 뒤에, 0을 1로, 1을 0으로 변환하는 연산자 이다.
  5. 왼쪽으로 시프트(shift) 연산하는 연산자 " << "
    왼쪽으로 비트를 움직이는 연산 ex) 5(101) 라는 값을 3번 << 하면 101000이 되어 40이 된다.
  6. 오른쪽으로 시프트(shift) 연산하는 연산자 " >> "
    10(1010)을 오른쪽으로 3번 >> 하면 0001이 된다. -> 시프트 연산을 하게 될 때, 비트의 위치가 최대값
    또는 최소값의 위치 이상으로 시프트할 경우에는 자동으로 버려진다.

    JavaScript 논리 연산자
  1. 논리곱 연산자 " && "
  2. 논리합 연산자 " || "
  3. 부정 연산자 " ! "
*/
